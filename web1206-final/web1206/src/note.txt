servlet服务端的小程序（写java程序，提供http访问）

一个类为什么是Servlet?
默认create new Servlet （语法，规范）
1. extends HttpServlet （代码，写在doGet(),doPost()方法中)
2. web.xml (配置servlet以及映射 url-servlet)
tomcat管理servlet,(创建new，调用doGet()，销毁)

ServletConfig, ServletContext
构造方法，发现init()方法，
HttpServlet,结构有些复杂。
Servlet相关类的结构，需要搞明白！

HttpServlet何以是一个Servlet
1. class XxxServlet extends MyServlet
2. class MyServlet（反射） extends HttpServlet
3. class HttpServlet extends GenericServlet
4. class GenericServlet implements Servlet, ServletConfig

成为Servlet的方式，实现Servlet接口！
tomcat根据接口编程，实例化响应的实现类，调用相应“约定”方法。

之前的说明，tomcat会根据请求方式的不同(get, post),相应地调用方法。

现在更加准备地表达：
客户访问：http://localhost:8080/aa
1. web.xml
 <servlet>
    <servlet-name>aaServlet</servlet-name>
    <servlet-class>com.woody.servlet.AaServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>aaServlet</servlet-name>
    <url-pattern>/aa</url-pattern>
</servlet-mapping>
根据解析url, 发现是AaServlet类提供服务。
tomcat创建com.woody.servlet.AaServlet对象。
new AaServlet()

2. init() 调用初始化方法
（GenericServlet 的init（）方法中，会对ServletConfig进行设置）

3. 创建request, response对象
4. 调用service方法，把request, response对象传入，通过该方法来提供服务。
对于开发者而言，主要工作就是，在service方法中，编写相应的项目代码（可以使用request,response)

interface Servlet 是成为Servlet的根本
GenericServlet 起到的作用是：做初始化的设置工作！(与ServletConfig, ServletContext建立联系)
HttpServlet 起到的作用是：重写了service方法，根据请求的方式不同，而调用相应的doXxx()方法
MyServlet extends HttpServlet ，根据实际的需要，重写doGet或doPost方法就可以了。


客户访问：http://localhost:8080/ac，get请求  后端是如何创建对象和调用方法的？
1. new AcServlet()
2. 调用service()方法，AcServlet没有定义service，
3. 就会找到它的父类HttpServlet中的service
4. 在HttpServlet中的service中，逻辑是根据请求方法不同而调用不同的方法。
5. 发现这是get请求，就会调用doGet方法
6. 根据方法调用的“对象类型最低阶原则”。在AcServlet类中找到doGet方法，最后提供服务。

ServletConfig   servlet的配置对象
ServletContext/ApplicationContext  应用/项目上下文对象

每个servlet都有一个servletConfig.
每个web app 都有一个ServletContext.
这个ServletContext有且只有一个，所有的servlet都可以访问！


键和值都是String类型
请求的信息（客户提供）
request.getParameter() 获取请求的参数

初始化数据（servlet, web app）
config.getInitParameter() 获取servlet中的配置参数
context.getInitParameter()获取web app中的配置参数

键是String类型，值是Object类型
后端处理请求过程中，不同组件的数据“共享” Object
request.getAttribute("name") 获取请求作用域的数据


从数据的共享引发出“作用域”不同的场景
1. request请求作用域（范围在一次http访问的过程）
2. servletContext 上下文作用域（范围整个web app的过程，说明全局，所有servlet都可以操作）
3. session作用域（会话作用域）


会话：有一定“上下文”（一个问答和另一个问答之间有“数据共享”的问题）
p1：吃了没有？
p2: 没有吃/ 吃过了
p1: 为什么没有吃？
p2: 没胃口


web不是这样？
tomcat做了什么？ 无差别的监听客户发来的所有的请求。
无差别：不管是哪个客户，只要发送请求，可以提供服务。

不同的服务之间，数据是如何联系的呢？
ServletContext 上下文作用域可以“共享”所有服务的数据。
不同的服务之间，数据共享。


http协议的特点 “无状态” 每次http访问之间，是独立，没有联系！


服务器如何识别“同一个”客户？
服务器如何保存这同一个客户的数据？以便这个客户不同的访问中数据可以“共享”
会话作用域 session. 可以保存会话作用域中！

配合，约定：打破“无状态”
服务器，会“自动”地
1. 创建session,
2. 查询session,
3. 把sessionId数据返回给浏览器
浏览器（客户端），会“自动”地
访问服务器的时候，会把这个服务端之前发送给我cookie，自动地放在请求的数据中！




场景：
页面：1.商品 2.购物 3. 结账 4. 结果
服务：1.挑选商品 2. 确定商品  3. 付款 4. 显示购买情况

1. 定义一个商品页面，（挑选商品)
2. 进入到购物车页面，点击确定
3. 进入到结账页面。点击付款
4. 进入到完成，显示购买的商品


1. 客户进入商品页面，挑选了商品  （进入购物车页面）
2. 跳转的购物车页面。购物车页面怎么知道是谁挑选的这个商品呢？ （结账）
引入需求：
同一个客户，不同的http访问，需要数据“共享”。
如何做到？
tomcat,servlet规范，提供很特殊的类 “HttpSession” http会话

通过request.getSession(),
从请求的数据中，查询是否有cookie携带jsessionId的数据
    1. 如果有，说明是一个“老客户”
        获取到jsessionId的值，通过jsessionId的值，找到相应的session对象。
    2. 如果没有
        说明是一个“新客户”，创建一个session,并且把这个session对象
        放在服务器端，通过一个键值对进行操作。
        同时把键，以cookie的形式，发送给客户端。


问： 会话中需要使用的数据保存在服务器还是客户端？
答： 服务器。

问： 能够认出是哪个客户信息的数据，保存在服务器还是客户端？
答： 客户端和服务端都要保存 jsessionId

问： 服务端需要保存很多的jsessionId吗？
答： 肯定的，不同的客户端都需要一个属性那个客户“自己”的jsessionId

问： 同一个客户端需要保存多个jsessionId吗？
答： 不需要，只要让服务器“记住自己”，所以，只需要一个。

问： 按照现在设置，如果浏览器“禁用”了cookie就不能进行会话了，这个说法正确吗？
答： 正确！

问： 如果浏览器“禁用”了cookie就不能进行会话了该怎么办？
答： url重写

注意：
session保存在服务器
cookie保存在客户端
session是通过，jsessionId为键的cookie对象，实现的。
一般而言，cookie技术，让session成为可能！

session有过期设置。
会话的信息可以“遗忘”
设置session过期的3种方式
1. 设置过期 session.invalidate()  场景：推出登入
2. 设置最大不活动的时间间隔,单位是秒 session.setMaxInactiveInterval(10); 场景：银行操作
3. 在web.xml中设置，时间单位是分钟 好处，让服务器不会“爆炸”
<session-config>
    <session-timeout>10</session-timeout>
</session-config>


session:用处
让同一个客户，不同的请求，能够做到数据的“共享”。
场景：
1. 购物车流程（挑选，结账）
2. 登陆（记住当前用户）

Cookie 曲奇（丹麦皇冠），web与cookie的关系是什么呢？

登陆服务，验证用户和密码。
登陆的页面，记住密码


1. 记住密码
2. 7天内记住密码 时间有效性（cookie）
3. 自动登入  (可以取消自动登入）












